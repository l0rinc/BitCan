<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="favicon.png">
    <title>BitCan: DIY Bitcoin Seed Storage</title>
    <style>
        :root {
            --background-gradient: radial-gradient(circle, white 0%, rgb(184, 183, 183) 100%);
            --box-shadow: 0 0.3em 0.4em rgba(0, 0, 0, 0.1);
            --light-grey-border: 0.1em solid #ccc;
            --font-family-monospace: 'Courier New', monospace;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 0.2em;
            background: var(--background-gradient);
            max-width: 60em;
            margin: 0.3em auto;
        }

        h1 {
            margin: 1em 0;
            font-size: 1.5em;
            text-align: center;
        }

        summary {
            cursor: pointer;
        }

        .clickable {
            cursor: pointer;
        }

        .word-box {
            width: 3em;
            padding: 0.3em;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(145deg, #ffffff, #e6e6e6);
            box-shadow: var(--box-shadow);
            border: var(--light-grey-border);
            border-radius: 0.5em;
        }

        .word-box.smaller {
            float: left;
            margin-right: 0.5em;
        }

        .centered-images {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 1em;
        }

        .centered-images img {
            max-width: 15em;
            max-height: 15em;
            width: auto;
            height: auto;
            box-shadow: var(--box-shadow);
            cursor: pointer;
        }

        .section {
            border: var(--light-grey-border);
            padding: 1em;
            margin-top: 1em;
            border-radius: 0.5em;
        }

        .template-svg-container {
            display: flex;
            justify-content: center;
            margin-top: 1em;
        }

        .template-svg {
            margin-top: 1em;
            cursor: pointer;
            box-shadow: var(--box-shadow);
        }

        line.light {
            stroke: lightgrey;
            stroke-width: 2;
            stroke-dasharray: 3;
        }

        line.bold {
            stroke: black;
            stroke-width: 4;
        }

        .section-header {
            width: 100%;
            text-align: center;
            font-family: var(--font-family-monospace);
            font-size: 2em;
            font-weight: bold;
            border-bottom: var(--light-grey-border);
            line-height: normal;
            box-shadow: var(--box-shadow);
        }

        .section-header::after {
            display: inline-block;
            vertical-align: middle;
            background: white;
            position: relative;
        }

        .toc-item {
            display: inline-block;
            margin: 0 0.3em 0.9em;
            padding: 0.3em;
            width: 1.5em;
            border: var(--light-grey-border);
            border-radius: 0.3em;
            background-color: #f8f8f8;
            box-shadow: var(--box-shadow);
            cursor: pointer;
        }

        #wordsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5em;
            justify-content: center;
        }

        #tocContainer {
            text-align: center;
            margin-bottom: 1.2em;
        }

        @media print {
            body {
                background: none;
            }

            #tocContainer, .toc-item {
                display: none;
            }

            .word-box {
                background: white;
                box-shadow: none;
                page-break-inside: avoid;
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
<div>
    <article>
        <h1>BitCan: DIY Bitcoin Seed Storage</h1>
        <div class="article-animation-container">
            <div class="word-box smaller" id="animationContainer"></div>
        </div>
        <p><a href="https://github.com/paplorinc/BitCan">BitCan</a> provides a durable and cost-effective solution for securing your <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank">Bitcoin mnemonic seed phrases</a>.</p>
        <p>Utilizing off-the-shelf materials such as a beer can and a screwdriver, BitCan creates a resilient alternative to paper wallets for storing Bitcoin wallet recovery information.</p>
        <p>Designed as an economical substitute for <a href="https://jlopp.github.io/metal-bitcoin-storage-reviews" target="_blank">commercially available metal plates</a>, BitCan enhances the protection of your walletâ€™s seed phrase from common risks, including moisture damage and exposure to heat (but not big fires).</p>
        <p>Moreover, its discreet design offers additional security by making the storage medium less recognizable and understandable to those who might come across it, such as cleaning staff or potential intruders.</p>
        <div class="section centered-images">
            <a href="img/img_1.jpg" target="_blank"><img src="img/img_1.jpg" alt="Seed storage preparation from a repurposed aluminium can."/></a>
            <a href="img/img_2.jpg" target="_blank"><img src="img/img_2.jpg" alt="Encoding the existing seed phrase into glyphs using the provided chart."/></a>
            <a href="img/img_3.jpg" target="_blank"><img src="img/img_3.jpg" alt="Tracing glyphs using a screwdriver."/></a>
            <a href="img/img_4.jpg" target="_blank"><img src="img/img_4.jpg" alt="Removing the sticker from the can."/></a>
            <a href="img/img_5.jpg" target="_blank"><img src="img/img_5.jpg" alt="The completed seed plate with engraved glyphs."/></a>
            <a href="img/img_6.jpg" target="_blank"><img src="img/img_6.jpg" alt="Final storage, plate rolled up"/></a>
        </div>
        <details class="section">
            <summary>Encoding Instructions</summary>
            <details class="section" open="open">
                <summary>Sticker Template</summary>
                <p>Print the template, stick it on az aluminium can, draw your seed phrase on the print, then etch through the sticker with a screwdriver.</p>
                <div>
                    <label><input type="radio" name="orientation" value="portrait">Portrait</label>
                    <label><input type="radio" name="orientation" value="landscape" checked>Landscape</label>
                    <label><input type="checkbox" name="alignmentMarks" checked>Alignment Marks</label>
                    <label><input type="checkbox" name="cornerMarks" checked>Corner Marks</label>
                    <label><input type="radio" name="layout" value="2x6" checked>2x6</label>
                    <label><input type="radio" name="layout" value="3x4">3x4</label>
                    <label><input type="range" name="scale" min="1" max="4" value="2">Scale</label>
                    <label><input type="checkbox" name="webLink" checked>Web Link</label>
                </div>
                <div class="template-svg-container"></div>
            </details>
            <details class="section">
                <summary>Details</summary>
                <ol>
                    <li>Securely generate your mnemonic seed phrase using a trusted, offline hardware wallet.</li>
                    <li>Flatten an aluminum can into a sheet and then attach the printed template to it - or draw it onto a piece of paper and affix it to the can.</li>
                    <li>Translate the words into glyphs, ensuring each corresponds accurately to the provided list.</li>
                    <li>Etch each glyph carefully onto the metal, double-checking for precision and verifying the sequence by reviewing it in reverse.</li>
                    <li>Use a screwdriver for etching the glyphs into the metal.</li>
                    <li>To ensure security and privacy, store the etched metal in a location that is both secure and discreet.</li>
                    <li class="clickable" onclick="window.print()">Print the table below into a PDF and back it up.</li>
                </ol>
            </details>

        </details>
        <details class="section">
            <summary>Decoding Instructions</summary>
            <ol>
                <li>First, transcribe all glyphs carefully onto a sheet of paper. This will serve as a more reliable reference than working directly from the plate.</li>
                <li>Identify the bottom square of each glyph first, as it provides a stable starting point for the decoding process.</li>
                <li>Then, identify the top square of the glyph to refine your search within the identified section of the word list.</li>
                <li>Alternatively, you can use binary search to navigate through the word list, since each line in the glyph halves the search area.</li>
                <li>Verify the transcribed seed phrase with your wallet to ensure its accuracy and integrity.</li>
            </ol>
        </details>
    </article>
</div>
<div class="section">
    <div id="tocContainer"></div>
    <div id="wordsContainer"></div>
</div>

<script>
    const wordsContainer = document.getElementById('wordsContainer');
    const tocContainer = document.getElementById('tocContainer');
    const width = 50;
    const height = 2 * width;
    const lineInset = 5.5;
    const lines = [
        [lineInset, 0, width - lineInset, 0],
        [0, lineInset, 0, width - lineInset],
        [lineInset, lineInset, width - lineInset, width - lineInset],
        [width - lineInset, lineInset, lineInset, width - lineInset],
        [width, lineInset, width, width - lineInset],

        [lineInset, width, width - lineInset, width],
        [0, width + lineInset, 0, height - lineInset],
        [lineInset, width + lineInset, width - lineInset, height - lineInset],
        [width - lineInset, width + lineInset, lineInset, height - lineInset],
        [width, width + lineInset, width, height - lineInset],

        [lineInset, height, width - lineInset, height],
    ];
    const binaryLength = lines.length;
    const animationCycle = binaryLength * 2;

    let currentIndex = 0;

    function drawCurrent(animationContainer) {
        animationContainer.innerHTML = '';

        const index = (1 << (binaryLength - Math.abs((currentIndex % animationCycle) - binaryLength))) >> 1;
        renderWordAndGlyph(animationContainer, "", index);

        currentIndex = (currentIndex + 1) % animationCycle;
    }

    setInterval(() => drawCurrent(document.getElementById('animationContainer')), 500);

    function asBinary(num) {
        return num.toString(2).padStart(binaryLength, '0');
    }

    function renderWordAndGlyph(container, word, index) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        let svgHeight = height + 2 * lineInset + 10;
        let y = 0;

        if (word.length) {
            y += 20;
            svgHeight += 20;

            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute("x", width / 2);
            textElement.setAttribute("y", 10);
            textElement.setAttribute("text-anchor", "middle");
            textElement.setAttribute("style", "font: 0.8em 'Courier New', monospace;");

            const boldTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            boldTspan.setAttribute("style", "font-weight: bold;");
            boldTspan.textContent = word.substring(0, 4);
            textElement.appendChild(boldTspan);

            if (word.length > 4) {
                const normalTspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                normalTspan.textContent = word.substring(4);
                textElement.appendChild(normalTspan);
            }

            svg.appendChild(textElement);
        }
        svg.setAttribute("viewBox", `${-lineInset} ${-lineInset} ${width + 2 * lineInset} ${svgHeight}`);


        const binaryString = asBinary(index);

        drawChar(svg, binaryString.split('').reverse().join(''), true, 0, y);

        const binaryTextElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        binaryTextElement.setAttribute("x", width / 2);
        binaryTextElement.setAttribute("y", svgHeight - 10);
        binaryTextElement.setAttribute("text-anchor", "middle");
        binaryTextElement.setAttribute("style", "font: 0.55em 'Courier New', monospace;");

        for (const char of binaryString) {
            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            tspan.setAttribute("style", "font-style: italic;");
            parseInt(char) && tspan.setAttribute("style", "font-style: italic; font-weight: bold;");
            tspan.textContent = char;
            binaryTextElement.appendChild(tspan);
        }

        svg.appendChild(binaryTextElement);
        container.appendChild(svg);

        container.appendChild(svg);
    }

    function drawChar(svg, binaryString, drawRect, x, y) {
        if (drawRect) {
            const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            background.setAttribute('x', x);
            background.setAttribute('y', y);
            background.setAttribute('width', width);
            background.setAttribute('height', height);
            background.setAttribute('fill', 'OldLace');
            background.setAttribute('rx', 3);
            svg.appendChild(background);
        }

        function drawLine(svg, x1, y1, x2, y2, isBold) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke-linecap', 'round');
            line.classList.add(isBold ? 'bold' : 'light');
            svg.appendChild(line);
        }

        "01".split('').forEach(char => {
            lines.forEach((points, index) => {
                if (binaryString[index] === char) {
                    drawLine(svg, x + points[0], y + points[1], x + points[2], y + points[3], char === '1');
                }
            });
        });
    }

    function fetchAndDisplayWords() {
        fetch('https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt')
            .then(response => response.text())
            .then(text => text.trim().split('\n'))
            .then(words => {
                let lastLetter = '';
                words.forEach((word, index) => {
                    word = word.toUpperCase();
                    if (word[0] !== lastLetter) {
                        lastLetter = word[0];

                        const sectionHeader = document.createElement('div');
                        sectionHeader.className = 'section-header';
                        sectionHeader.innerText = lastLetter;
                        wordsContainer.appendChild(sectionHeader);

                        const button = document.createElement('button');
                        button.className = "toc-item";
                        button.textContent = lastLetter;
                        button.onclick = () => sectionHeader.scrollIntoView({behavior: 'smooth', block: 'start'});
                        tocContainer.appendChild(button);
                    }

                    const wordBox = document.createElement('div');
                    wordBox.className = 'word-box';
                    renderWordAndGlyph(wordBox, word, asBinary(index));
                    wordsContainer.appendChild(wordBox);
                });
            });
    }

    fetchAndDisplayWords();

    function drawTemplateSVG() {
        function createSVGLine(svg, x1, y1, x2, y2, lineWidth) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("stroke", "black");
            line.setAttribute("stroke-width", lineWidth);
            line.setAttribute("stroke-linecap", "round");
            svg.appendChild(line);
        }

        const glyphWidth = width;
        const inset = width;
        const lineWidth = 2;

        const orientation = document.querySelector('input[name="orientation"]:checked').value;
        const alignmentMarks = document.querySelector('input[name="alignmentMarks"]').checked;
        const layout = document.querySelector('input[name="layout"]:checked').value;
        const scale = parseFloat(document.querySelector('input[name="scale"]').value) / 3;
        const webLink = document.querySelector('input[name="webLink"]').checked;
        const cornerMarks = document.querySelector('input[name="cornerMarks"]').checked;

        let [glyphsPerRow, glyphsPerCol] = layout === '2x6' ? [2, 6] : [3, 4];
        if (orientation === 'portrait') [glyphsPerRow, glyphsPerCol] = [glyphsPerCol, glyphsPerRow];

        const totalWidth = inset * 2 + glyphWidth * (glyphsPerCol * 2 - 1);
        const totalHeight = inset * 2 + glyphWidth * (glyphsPerRow * 3 - 1);

        function prepareTemplate() {
            const template = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            template.classList.add('template-svg');
            template.setAttribute("width", totalWidth * scale);
            template.setAttribute("height", totalHeight * scale);
            template.setAttribute("viewBox", `${-lineWidth} ${-lineWidth} ${totalWidth + 2 * lineWidth} ${totalHeight + 2 * lineWidth}`);

            const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            background.setAttribute('width', totalWidth);
            background.setAttribute('height', totalHeight);
            background.setAttribute('fill', 'white');
            background.setAttribute('stroke', 'grey');
            template.appendChild(background);
            return template;
        }

        const template = prepareTemplate();
        for (let row = 0; row < glyphsPerRow; row++) {
            for (let col = 0; col < glyphsPerCol; col++) {
                const x = inset + col * 2 * glyphWidth;
                const y = inset + row * 3 * glyphWidth;
                drawChar(template, '00000000000', false, x, y);
            }
        }

        const halfGlyphWidth = glyphWidth / 2;
        if (alignmentMarks) {
            const [offsetX, offsetY] = [inset + glyphWidth * 1.5, inset + glyphWidth * 2.5];
            for (let row = 1; row < glyphsPerRow; row++) {
                for (let col = 1; col < glyphsPerCol; col++) {
                    const x = offsetX + (col - 1) * glyphWidth * 2;
                    const y = offsetY + (row - 1) * glyphWidth * 3;
                    createSVGLine(template, x, y - halfGlyphWidth + lineWidth, x, y + halfGlyphWidth - lineWidth, lineWidth);
                    createSVGLine(template, x - halfGlyphWidth + lineWidth, y, x + halfGlyphWidth - lineWidth, y, lineWidth);
                }
            }
        }

        if (webLink) {
            const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textElement.setAttribute("x", "50%");
            textElement.setAttribute("y", 20);
            textElement.setAttribute("text-anchor", "middle");
            textElement.setAttribute("style", "font: italic 16px Arial;");
            textElement.textContent = "https://bitcan.world";
            template.appendChild(textElement);
        }

        if (cornerMarks) {
            const offset = lineWidth / 2;
            createSVGLine(template, offset, offset, offset, halfGlyphWidth + offset, lineWidth);
            createSVGLine(template, offset, offset, halfGlyphWidth + offset, offset, lineWidth);

            createSVGLine(template, totalWidth - offset, offset, totalWidth - offset, halfGlyphWidth + offset, lineWidth);
            createSVGLine(template, totalWidth - offset, offset, totalWidth - halfGlyphWidth, offset, lineWidth);

            createSVGLine(template, offset, totalHeight - offset, offset, totalHeight - halfGlyphWidth - offset, lineWidth);
            createSVGLine(template, offset, totalHeight - offset, halfGlyphWidth + offset, totalHeight - offset, lineWidth);
        }

        template.addEventListener('click', () => {
            const target = template.cloneNode(true)
            const styleElement = document.createElementNS("http://www.w3.org/2000/svg", "style");
            styleElement.textContent = `
                line.light {
                    stroke: lightgrey;
                    stroke-width: ${lineWidth};
                    stroke-dasharray: 3;
                }
            `;
            target.insertBefore(styleElement, target.firstChild);

            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(target);
            const blob = new Blob([svgStr], {type: "image/svg+xml"});
            const win = window.open(URL.createObjectURL(blob), '_blank');
            win.print();
        });

        const svgContainer = document.querySelector('.template-svg-container');
        svgContainer.innerHTML = '';
        svgContainer.appendChild(template);
    }

    document.querySelectorAll('input[name="orientation"], input[name="alignmentMarks"], input[name="layout"], input[name="scale"], input[name="webLink"], input[name="cornerMarks"]')
        .forEach(input => input.addEventListener('input', drawTemplateSVG));

    drawTemplateSVG();
</script>
</body>
</html>
